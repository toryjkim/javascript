# ch1. what is scope?
변수에 값을 저장하고 수정하는 것은 프로그램의 상태를 관리하는 것과 같다. 그렇다면 변수는 어디에 저장되는가? 프로그램은
어떻게 이 변수들을 찾을까? 이러한 의문을 통해 알 수 있는 점은 곧 변수가 어떻게 저장되고 프로그램이 어떻게 변수를 찾을 수 있는지 규칙이 필요하다는 점이다. 이런 규칙을 바로 `Scope`라 한다.

## 1. compiler Theory
자바스크립트가 인터프리터 언어로 알려져지만, 자바스크립트는 컴파일 언어이기도하다. 하지만 일반적인 컴파일 언어와는 다른점이있다.
우선 일반적인 컴파일 과정부터 살펴보자.

1. Tokenizing/Lexing: 
문자들을 토큰별로 나눈다. 예를들어 `var a = 2;`를 `var`, `a`, `=`, `2`, `;` 5개의 토큰으로 분리한다.
**Note**: tokenizing이 문자들을 각각의 토큰으로 분리하는 것이라면, lexing은 각각의 토큰을 구별할 수 있게 한다.
2. Parsing: 토큰들을 취해 프로그램의 전체 구조를 나타내는 트리를 만들어 낸다. 컴파일러는 이 트리를 보고 빠르게 코드의 구조를 파악해서 
에러를 찾아내거나 코드를 변형시킬 수 있다. 
이러한 트리는 상위 엘리먼트에서 부터 하위 엘리먼트로 이어지는 노드로 구성되고 "AST(Abstract Syntzs Tree)" 라고 부른다.
3. Code-Generation:
AST를 보고 실행가능한 코드로 바꾸는 과정이다. 

자바스크립트는 위의 3가지 단계보다 더 복잡한 과정을 거친다. 
예를들어 Parsing과 Code-Genration과정 중에 중복 요소를 제거하는 등의 성능을 최적화하는 단계가 포함된다.

## 2. Understanding Scope
Scrope를 이해하기 위해 다음 세가지를 알고 넘어가자.
1. Engine(엔진): 컴파일러를 불러 컴파일을 하도록 명령하고, 자바스크립트 프로그램을 실행한다.
2. Compiler(컴파일러): Parsing과 code-generation을 수행한다. ( 토큰을 분석해서 AST를 만들고, 실행가능한 코드로 만드는 것. )
3. Scope(스코프): 선언된 모든 식별자(변수)를 리스트화하고, 어떻게 이 변수에 접근할지 엄격한 규정을 정해 변수들을 관리한다.  

### 2.1. Back & Forth
일반적으로 사람이 보기에는 `var a = 2;`가 하나의 명령이지만, Engine에게는 구분되는 두개의 명령이다. 
첫번째는 컴퍼일러가 `var a = 2;`를 컴파일하는 동안 일어나는 과정, 두번째는 Engine이 이 명령문을 실행하는 과정이다.
이제 Engine의 입장에서 `var a = 2;`를 살펴보자.

1. 컴파일러가 `var a`를 만나면 스코프에게 변수 a 가 존재하는지 묻는다.(a가 속한 스코프) 만약 있다면, 컴파일러는 선언을 무시하고 다음으로 넘어간다. 반대로 없다면 스코프에게 새로운 변수 a를 생성할 것을 요청한다.
2. 그 후 컴파일러는 a에 2를 할당하라는 실행 코드를 생성한다. 이 코드는 엔진에 의해 실행되고, 코드는 스코프에게 변수 a에 접근이 가능한지 묻는다. 접근이 가능하면 엔진은 그 변수를 사용한다. 반대로 없다면, 엔진은 상위 스코프를 찾아간다. 마침네 엔진이 변수를 찾아내면, 2는 변수 a에 할당된다. 끝끝내 찾지 못했다면 에러를 반환한다.

**요약**
1단계: 컴파일러가 변수를 선언한다. 2단계: 코드가 실행될때, 엔진은 변수를 스코프 내에서 변수를 찾고 변수에 값을 할당한다.

### 2.2. Compier Speak
2단계에서 코드가 실행되고 엔진은 변수를 찾는다. 하지만 이때 엔진이 사용하는 검색 종류에 따라 검색 결과가 달라진다.
#### 검색 종류
1. LHS : 변수가 대입 연산자의 왼쪽에 있을 때 수행 ex) `a = 10`
2. RHS : 변수가 대입 연산자의 오른쪽에 있을 때 수행   `console.log( a )`

좀 더 자세하게 알아보자.
`console.log( a );` 에서 a는 RHS 참조이다. 왜냐하면 변수 `a`에 아무것도 할당하지 않고, 단지 a를 찾아 값 반환하기 때문이다.

반면 `a = 10`의 경우 LHS 참조이다. 왜냐하면 a를 찾아 `=` 할당 연산을 수행하기 때문이다.

다음 예제는 LHS와 RHS 둘다 사용한다.
```
fucntion foo(a) {
  console.log( a ); //2
}

foo( 2 );
```
1. 마지막 라인에서 foo(..)는 함수 를 불러온다. 여기서 `foo`가 foo의 값이 뭐야? 그리고 그것을 나에게 줘 라는 의미이다. 즉 **RHS**이다. 그리고 (..)는 그 값을 실행한다는 의미이므로 함수여야 한다. 

2. 이곳에서 `a = 2` **LHS**도 수행한다. 어디서? 2가 foo의 값으로 입력됐을 때, foo의 매개변수 a에 2가 할당된다. 

3. console.log에서 사용되는 변수 a는 또하나의 **RHS**가 있다. a의 값을 찾아 console.log(..)의 값으로 넘겨준다.

4. 마지막으로 위의 1,2,3번 과정을 통해 우리는 값 `2`(a의 변수로 부터 RHS한 값) 이 console.log( a ); 로 전달되는 과정에서  또한 번의 RHS와 LHS가 수행될 것임을 개념화 할 수 있다. `log`의 변수 값을 불러오고(RHS), 그 값을 (..) 실행해서 log 함수에게 2값을 전달한다. 2값을 전달하는 과정에서 아마도 `arg1`과 같은 매개변수에 2값이 할당되며 LHS 검색을 또 한번 수행할 것 이다.

즉, 엔진은 변수를 찾아 이 변수를 다루는 두가지 방법이 존재한다.
1. RHS는 변수를 찾아 값을 반환하다.
2. LHS는 변수를 찾아 값을 할당한다.

**NOTE**
함수가 선언되고 할당되는 것도 LHS라고 생각할 수 있으나 별개로 생각해야한다.
왜냐하면 `var foo` and `foo = function(a){...`는 모두 컴파일러가 코드를 생성할 때 이미 처리하기 때문이다. 즉 함수의 할당은 엔진이 수행하지 않아서 `LHS`라고 생각하면 안된다.

## 3. Nested Scope

## 4. Errors
